{"title": "Prefixes lookup (0.22)", "description": "Sequence prefixes lookupThis approach is described in Neil Sloane's book Encyclopedia of Integer Sequences (chapter 2.5: analysis of differences). Suppose we have a sequence [ 1, 8, 27, 64, 125, 216 ] and want to predict next term. This sequence is cubes: f(n)=n3. An array of differences is [ 8 - 1, 27 - 8, 64 - 27, 125 - 64, 216 - 125 ] = [ 7, 19, 37, 61, 91 ]. A simple quick look at this sequence doesn't let us recognize it. We'll define it as f1(n)=f0(n+1)\u2212f0(n) where f0(n)=f(n) is the original sequence. If we calculate differences once again, we get: [ 19 - 7, 37 - 19, 61 - 37, 91 - 61 ] = [ 12, 18, 24, 30 ]. And this pattern is already recognizable. Let's take one more: [ 18 - 12, 24 - 18, 30 - 24 ] = [ 6, 6, 6 ]. A constant value of 6. How to get a next element? We need to add one more constant 6 to the array of third differences. Then the next element of second differences f2(n)=f2(n\u22121)+f3(n\u22121). So, f2(5)=f2(4)+f3(4)=30+6=36. Analogously, f1(6)=f1(5)+f2(5)=91+36=127. Finally, f0(7)=f0(6)+f1(6)=216+127=343. Check: f(7)=73=343=f0(7) \u2013 correct. Another example: [ 1, 2, 4, 8, 16, 32, 64 ]. Differences: [ 2 - 1, 4 - 2, 8 - 4, 16 - 8, 32 - 16, 64 - 32 ] = [ 1, 2, 4, 8, 16, 32 ]. The result is the original sequence itself. We can take the next element from the first array: 64. Then the next element of original sequence is f0(8)=f0(7)+f1(7)=64+64=128. In many cases a next item of sequence can be predicted by calculating a next item of differences array. And if that array is recognizable then we are able to easily find the next item. It's possible to recognize an array by looking it up in a prefix tree (trie). That trie would contain not sequences themselves but their signatures. We'll use a definition of signature function suggested by Nina Chen in this article with a slight change: signature(seq)=sign(seq)\u22c6seqGCD(seq). Here, sign is a sign of the first non-zero item of sequence seq (+1 if the item is positive, or -1 otherwise) and GCD is a greatest common divisor of all sequence elements. Example: sequence [ 2, 4, 6, 8 ] would be stored in a trie as [ 1, 2, 3, 4 ] because GCD( [ 2, 4, 6, 8 ] ) = 2 and we divide each element of sequence by GCD. A GCD function definition (taken from Nina Chen's article):", "link": "https://www.kaggle.com/balzac/prefixes-lookup-0-22", "tags": [], "kind": ["Project", "(Notebook)"], "ml_libs": ["pattern"], "host": "kaggle.com", "license": "Apache-2.0", "language": "english", "date_project": "2016-07-18 11:27:48", "date_scraped": "2020-12-13 11:57:13", "words": 425, "sentences": 29, "sum_nltk": "Sequence prefixes lookupThis approach is described in Neil Sloane's book Encyclopedia of Integer Sequences (chapter 2.5: analysis of differences).\nAn array of differences is [ 8 - 1, 27 - 8, 64 - 27, 125 - 64, 216 - 125 ] = [ 7, 19, 37, 61, 91 ].\nA simple quick look at this sequence doesn't let us recognize it.\nWe'll define it as f1(n)=f0(n+1)\u2212f0(n) where f0(n)=f(n) is the original sequence.\nWe need to add one more constant 6 to the array of third differences.\nThen the next element of second differences f2(n)=f2(n\u22121)+f3(n\u22121).\nThe result is the original sequence itself.\nWe can take the next element from the first array: 64.\nThen the next element of original sequence is f0(8)=f0(7)+f1(7)=64+64=128.\nIn many cases a next item of sequence can be predicted by calculating a next item of differences array.\nIt's possible to recognize an array by looking it up in a prefix tree (trie).\nExample: sequence [ 2, 4, 6, 8 ] would be stored in a trie as [ 1, 2, 3, 4 ] because GCD( [ 2, 4, 6, 8 ] ) = 2 and we divide each element of sequence by GCD.\nA GCD function definition (taken from Nina Chen's article):", "sum_nltk_words": 193, "sum_nltk_runtime": 0.004, "sum_t5": "f0(n)=f(n) where f0(n)=f(n) is the original sequence. f0(n)=f(n) is the next element of the sequence. f0(n)=f(n) is the next element of the sequence. f0(n)=f(n) is the next element of the sequence. f0(n)=f(n) is the next element of the sequence.", "sum_t5_words": 39, "sum_t5_runtime": 6.726, "runtime": 0.004, "nltk_category": "Utilities", "nltk_category_score": 0.3119974136352539, "nltk_category_runtime": 22.933, "nltk_subcategory": "Physical", "nltk_subcategory_score": 0.5807588696479797, "nltk_subcategory_runtime": 36.941, "category": "Utilities", "category_score": 0.3119974136352539, "subcategory": "Physical", "subcategory_score": 0.5807588696479797, "runtime_cat": 59.874, "programming_language": "Jupyter Notebook", "ml_score": "0.7", "engagement_score": "0.744", "language_code": "en", "language_score": "0.9999973045911787", "learn_score": 1, "explore_score": 0, "compete_score": 0, "description_lemmatized": "sequence prefix lookupthis approach described neil sloanes book encyclopedia integer sequence chapter 25 analysis difference suppose sequence 1 8 27 64 125 216 want predict next term sequence cube fnn3 array difference 8 1 27 8 64 27 125 64 216 125 7 19 37 61 91 simple quick look sequence doesnt let u recognize well define f1nf0n1f0n f0nfn original sequence calculate difference get 19 7 37 19 61 37 91 61 12 18 24 30 pattern already recognizable let take one 18 12 24 18 30 24 6 6 6 constant value 6 get next element need add one constant 6 array third difference next element second difference f2nf2n1f3n1 f25f24f3430636 analogously f16f15f259136127 finally f07f06f16216127343 check f773343f07 correct another example 1 2 4 8 16 32 64 difference 2 1 4 2 8 4 16 8 32 16 64 32 1 2 4 8 16 32 result original sequence take next element first array 64 next element original sequence f08f07f176464128 many case next item sequence predicted calculating next item difference array array recognizable able easily find next item possible recognize array looking prefix tree trie trie would contain sequence signature well use definition signature function suggested nina chen article slight change signatureseqsignseqseqgcdseq sign sign first nonzero item sequence seq 1 item positive 1 otherwise gcd greatest common divisor sequence element example sequence 2 4 6 8 would stored trie 1 2 3 4 gcd 2 4 6 8 2 divide element sequence gcd gcd function definition taken nina chen article", "tags_descriptive": []}